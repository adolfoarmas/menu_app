/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { fileURLToPath } = require("url");
const CommentCompilationWarning = require("../CommentCompilationWarning");
const RuntimeGlobals = require("../RuntimeGlobals");
const UnsupportedFeatureWarning = require("../UnsupportedFeatureWarning");
const WebpackError = require("../WebpackError");
const BasicEvaluatedExpression = require("../javascript/BasicEvaluatedExpression");
const {
	evaluateToIdentifier,
	evaluateToString,
	expressionIsUnsupported,
	toConstantDependency
} = require("../javascript/JavascriptParserHelpers");
const CommonJsFullRequireDependency = require("./CommonJsFullRequireDependency");
const CommonJsRequireContextDependency = require("./CommonJsRequireContextDependency");
const CommonJsRequireDependency = require("./CommonJsRequireDependency");
const ConstDependency = require("./ConstDependency");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");
const LocalModuleDependency = require("./LocalModuleDependency");
const { getLocalModule } = require("./LocalModulesHelpers");
const RequireHeaderDependency = require("./RequireHeaderDependency");
const RequireResolveContextDependency = require("./RequireResolveContextDependency");
const RequireResolveDependency = require("./RequireResolveDependency");
const RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");

<<<<<<< HEAD
/** @typedef {import("estree").CallExpression} CallExpression */
/** @typedef {import("estree").Expression} Expression */
/** @typedef {import("estree").NewExpression} NewExpression */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").ImportSource} ImportSource */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */
=======
/** @typedef {import("estree").CallExpression} CallExpressionNode */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions} JavascriptParserOptions */
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb

const createRequireSpecifierTag = Symbol("createRequire");
const createdRequireIdentifierTag = Symbol("createRequire()");

class CommonJsImportsParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options parser options
	 */
	constructor(options) {
		this.options = options;
	}

<<<<<<< HEAD
	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
=======
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
	apply(parser) {
		const options = this.options;

		const getContext = () => {
			if (parser.currentTagData) {
				const { context } = parser.currentTagData;
				return context;
			}
		};

		//#region metadata
<<<<<<< HEAD
		/**
		 * @param {TODO} expression expression
		 * @param {() => string[]} getMembers get members
		 */
=======
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
		const tapRequireExpression = (expression, getMembers) => {
			parser.hooks.typeof
				.for(expression)
				.tap(
					"CommonJsImportsParserPlugin",
					toConstantDependency(parser, JSON.stringify("function"))
				);
			parser.hooks.evaluateTypeof
				.for(expression)
				.tap("CommonJsImportsParserPlugin", evaluateToString("function"));
			parser.hooks.evaluateIdentifier
				.for(expression)
				.tap(
					"CommonJsImportsParserPlugin",
					evaluateToIdentifier(expression, "require", getMembers, true)
				);
		};
<<<<<<< HEAD
		/**
		 * @param {string | symbol} tag tag
		 */
=======
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
		const tapRequireExpressionTag = tag => {
			parser.hooks.typeof
				.for(tag)
				.tap(
					"CommonJsImportsParserPlugin",
					toConstantDependency(parser, JSON.stringify("function"))
				);
			parser.hooks.evaluateTypeof
				.for(tag)
				.tap("CommonJsImportsParserPlugin", evaluateToString("function"));
		};
		tapRequireExpression("require", () => []);
		tapRequireExpression("require.resolve", () => ["resolve"]);
		tapRequireExpression("require.resolveWeak", () => ["resolveWeak"]);
		//#endregion

		// Weird stuff //
		parser.hooks.assign
			.for("require")
			.tap("CommonJsImportsParserPlugin", expr => {
				// to not leak to global "require", we need to define a local require here.
				const dep = new ConstDependency("var require;", 0);
<<<<<<< HEAD
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.module.addPresentationalDependency(dep);
				return true;
			});

		//#region Unsupported
		parser.hooks.expression
			.for("require.main")
			.tap(
				"CommonJsImportsParserPlugin",
				expressionIsUnsupported(
					parser,
					"require.main is not supported by webpack."
				)
			);
		parser.hooks.call
			.for("require.main.require")
			.tap(
				"CommonJsImportsParserPlugin",
				expressionIsUnsupported(
					parser,
					"require.main.require is not supported by webpack."
				)
			);
		parser.hooks.expression
			.for("module.parent.require")
			.tap(
				"CommonJsImportsParserPlugin",
				expressionIsUnsupported(
					parser,
					"module.parent.require is not supported by webpack."
				)
			);
		parser.hooks.call
			.for("module.parent.require")
			.tap(
				"CommonJsImportsParserPlugin",
				expressionIsUnsupported(
					parser,
					"module.parent.require is not supported by webpack."
				)
			);
		//#endregion

		//#region Renaming
<<<<<<< HEAD
		/**
		 * @param {Expression} expr expression
		 * @returns {boolean} true when set undefined
		 */
		const defineUndefined = expr => {
			// To avoid "not defined" error, replace the value with undefined
			const dep = new ConstDependency(
				"undefined",
				/** @type {Range} */ (expr.range)
			);
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
		const defineUndefined = expr => {
			// To avoid "not defined" error, replace the value with undefined
			const dep = new ConstDependency("undefined", expr.range);
			dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			parser.state.module.addPresentationalDependency(dep);
			return false;
		};
		parser.hooks.canRename
			.for("require")
			.tap("CommonJsImportsParserPlugin", () => true);
		parser.hooks.rename
			.for("require")
			.tap("CommonJsImportsParserPlugin", defineUndefined);
		//#endregion

		//#region Inspection
		const requireCache = toConstantDependency(
			parser,
			RuntimeGlobals.moduleCache,
			[
				RuntimeGlobals.moduleCache,
				RuntimeGlobals.moduleId,
				RuntimeGlobals.moduleLoaded
			]
		);

		parser.hooks.expression
			.for("require.cache")
			.tap("CommonJsImportsParserPlugin", requireCache);
		//#endregion

		//#region Require as expression
<<<<<<< HEAD
		/**
		 * @param {Expression} expr expression
		 * @returns {boolean} true when handled
		 */
=======
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
		const requireAsExpressionHandler = expr => {
			const dep = new CommonJsRequireContextDependency(
				{
					request: options.unknownContextRequest,
					recursive: options.unknownContextRecursive,
					regExp: options.unknownContextRegExp,
					mode: "sync"
				},
<<<<<<< HEAD
				/** @type {Range} */ (expr.range),
=======
				expr.range,
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				undefined,
				parser.scope.inShorthand,
				getContext()
			);
			dep.critical =
				options.unknownContextCritical &&
				"require function is used in a way in which dependencies cannot be statically extracted";
<<<<<<< HEAD
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
			dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};
		parser.hooks.expression
			.for("require")
			.tap("CommonJsImportsParserPlugin", requireAsExpressionHandler);
		//#endregion

		//#region Require
<<<<<<< HEAD
		/**
		 * @param {CallExpression | NewExpression} expr expression
		 * @param {BasicEvaluatedExpression} param param
		 * @returns {boolean | void} true when handled
		 */
		const processRequireItem = (expr, param) => {
			if (param.isString()) {
				const dep = new CommonJsRequireDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (param.range),
					getContext()
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
		const processRequireItem = (expr, param) => {
			if (param.isString()) {
				const dep = new CommonJsRequireDependency(
					param.string,
					param.range,
					getContext()
				);
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
<<<<<<< HEAD
		/**
		 * @param {CallExpression | NewExpression} expr expression
		 * @param {BasicEvaluatedExpression} param param
		 * @returns {boolean | void} true when handled
		 */
		const processRequireContext = (expr, param) => {
			const dep = ContextDependencyHelpers.create(
				CommonJsRequireContextDependency,
				/** @type {Range} */ (expr.range),
=======
		const processRequireContext = (expr, param) => {
			const dep = ContextDependencyHelpers.create(
				CommonJsRequireContextDependency,
				expr.range,
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				param,
				expr,
				options,
				{
					category: "commonjs"
				},
				parser,
				undefined,
				getContext()
			);
			if (!dep) return;
<<<<<<< HEAD
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
			dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};
<<<<<<< HEAD
		/**
		 * @param {boolean} callNew true, when require is called with new
		 * @returns {(expr: CallExpression | NewExpression) => (boolean | void)} handler
		 */
		const createRequireHandler = callNew => expr => {
			if (options.commonjsMagicComments) {
				const { options: requireOptions, errors: commentErrors } =
					parser.parseCommentOptions(/** @type {Range} */ (expr.range));
=======
		const createRequireHandler = callNew => expr => {
			if (options.commonjsMagicComments) {
				const { options: requireOptions, errors: commentErrors } =
					parser.parseCommentOptions(expr.range);
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb

				if (commentErrors) {
					for (const e of commentErrors) {
						const { comment } = e;
						parser.state.module.addWarning(
							new CommentCompilationWarning(
								`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,
								comment.loc
							)
						);
					}
				}
				if (requireOptions) {
					if (requireOptions.webpackIgnore !== undefined) {
						if (typeof requireOptions.webpackIgnore !== "boolean") {
							parser.state.module.addWarning(
								new UnsupportedFeatureWarning(
									`\`webpackIgnore\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`,
<<<<<<< HEAD
									/** @type {DependencyLocation} */ (expr.loc)
=======
									expr.loc
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
								)
							);
						} else {
							// Do not instrument `require()` if `webpackIgnore` is `true`
							if (requireOptions.webpackIgnore) {
								return true;
							}
						}
					}
				}
			}

			if (expr.arguments.length !== 1) return;
			let localModule;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				let isExpression = false;
<<<<<<< HEAD
				for (const p of /** @type {BasicEvaluatedExpression[]} */ (
					param.options
				)) {
=======
				for (const p of param.options) {
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
					const result = processRequireItem(expr, p);
					if (result === undefined) {
						isExpression = true;
					}
				}
				if (!isExpression) {
<<<<<<< HEAD
					const dep = new RequireHeaderDependency(
						/** @type {Range} */ (expr.callee.range)
					);
					dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
					const dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
					parser.state.module.addPresentationalDependency(dep);
					return true;
				}
			}
			if (
				param.isString() &&
<<<<<<< HEAD
				(localModule = getLocalModule(
					parser.state,
					/** @type {string} */ (param.string)
				))
			) {
				localModule.flagUsed();
				const dep = new LocalModuleDependency(
					localModule,
					/** @type {Range} */ (expr.range),
					callNew
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
				(localModule = getLocalModule(parser.state, param.string))
			) {
				localModule.flagUsed();
				const dep = new LocalModuleDependency(localModule, expr.range, callNew);
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.module.addPresentationalDependency(dep);
				return true;
			} else {
				const result = processRequireItem(expr, param);
				if (result === undefined) {
					processRequireContext(expr, param);
				} else {
<<<<<<< HEAD
					const dep = new RequireHeaderDependency(
						/** @type {Range} */ (expr.callee.range)
					);
					dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
					const dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
					parser.state.module.addPresentationalDependency(dep);
				}
				return true;
			}
		};
		parser.hooks.call
			.for("require")
			.tap("CommonJsImportsParserPlugin", createRequireHandler(false));
		parser.hooks.new
			.for("require")
			.tap("CommonJsImportsParserPlugin", createRequireHandler(true));
		parser.hooks.call
			.for("module.require")
			.tap("CommonJsImportsParserPlugin", createRequireHandler(false));
		parser.hooks.new
			.for("module.require")
			.tap("CommonJsImportsParserPlugin", createRequireHandler(true));
		//#endregion

		//#region Require with property access
<<<<<<< HEAD
		/**
		 * @param {Expression} expr expression
		 * @param {string[]} calleeMembers callee members
		 * @param {CallExpression} callExpr call expression
		 * @param {string[]} members members
		 * @returns {boolean | void} true when handled
		 */
		const chainHandler = (expr, calleeMembers, callExpr, members) => {
			if (callExpr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(callExpr.arguments[0]);
			if (
				param.isString() &&
				!getLocalModule(parser.state, /** @type {string} */ (param.string))
			) {
				const dep = new CommonJsFullRequireDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (expr.range),
					members
				);
				dep.asiSafe = !parser.isAsiPosition(
					/** @type {Range} */ (expr.range)[0]
				);
				dep.optional = !!parser.scope.inTry;
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
		const chainHandler = (expr, calleeMembers, callExpr, members) => {
			if (callExpr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(callExpr.arguments[0]);
			if (param.isString() && !getLocalModule(parser.state, param.string)) {
				const dep = new CommonJsFullRequireDependency(
					param.string,
					expr.range,
					members
				);
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.optional = !!parser.scope.inTry;
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.current.addDependency(dep);
				return true;
			}
		};
<<<<<<< HEAD
		/**
		 * @param {CallExpression} expr expression
		 * @param {string[]} calleeMembers callee members
		 * @param {CallExpression} callExpr call expression
		 * @param {string[]} members members
		 * @returns {boolean | void} true when handled
		 */
		const callChainHandler = (expr, calleeMembers, callExpr, members) => {
			if (callExpr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(callExpr.arguments[0]);
			if (
				param.isString() &&
				!getLocalModule(parser.state, /** @type {string} */ (param.string))
			) {
				const dep = new CommonJsFullRequireDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (expr.callee.range),
					members
				);
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(
					/** @type {Range} */ (expr.range)[0]
				);
				dep.optional = !!parser.scope.inTry;
				dep.loc = /** @type {DependencyLocation} */ (expr.callee.loc);
=======
		const callChainHandler = (expr, calleeMembers, callExpr, members) => {
			if (callExpr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(callExpr.arguments[0]);
			if (param.isString() && !getLocalModule(parser.state, param.string)) {
				const dep = new CommonJsFullRequireDependency(
					param.string,
					expr.callee.range,
					members
				);
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(expr.range[0]);
				dep.optional = !!parser.scope.inTry;
				dep.loc = expr.callee.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.current.addDependency(dep);
				parser.walkExpressions(expr.arguments);
				return true;
			}
		};
		parser.hooks.memberChainOfCallMemberChain
			.for("require")
			.tap("CommonJsImportsParserPlugin", chainHandler);
		parser.hooks.memberChainOfCallMemberChain
			.for("module.require")
			.tap("CommonJsImportsParserPlugin", chainHandler);
		parser.hooks.callMemberChainOfCallMemberChain
			.for("require")
			.tap("CommonJsImportsParserPlugin", callChainHandler);
		parser.hooks.callMemberChainOfCallMemberChain
			.for("module.require")
			.tap("CommonJsImportsParserPlugin", callChainHandler);
		//#endregion

		//#region Require.resolve
<<<<<<< HEAD
		/**
		 * @param {CallExpression} expr call expression
		 * @param {boolean} weak weak
		 * @returns {boolean | void} true when handled
		 */
=======
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
		const processResolve = (expr, weak) => {
			if (expr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
<<<<<<< HEAD
				for (const option of /** @type {BasicEvaluatedExpression[]} */ (
					param.options
				)) {
=======
				for (const option of param.options) {
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
					const result = processResolveItem(expr, option, weak);
					if (result === undefined) {
						processResolveContext(expr, option, weak);
					}
				}
<<<<<<< HEAD
				const dep = new RequireResolveHeaderDependency(
					/** @type {Range} */ (expr.callee.range)
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.module.addPresentationalDependency(dep);
				return true;
			} else {
				const result = processResolveItem(expr, param, weak);
				if (result === undefined) {
					processResolveContext(expr, param, weak);
				}
<<<<<<< HEAD
				const dep = new RequireResolveHeaderDependency(
					/** @type {Range} */ (expr.callee.range)
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.module.addPresentationalDependency(dep);
				return true;
			}
		};
<<<<<<< HEAD
		/**
		 * @param {CallExpression} expr call expression
		 * @param {BasicEvaluatedExpression} param param
		 * @param {boolean} weak weak
		 * @returns {boolean | void} true when handled
		 */
		const processResolveItem = (expr, param, weak) => {
			if (param.isString()) {
				const dep = new RequireResolveDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (param.range),
					getContext()
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
		const processResolveItem = (expr, param, weak) => {
			if (param.isString()) {
				const dep = new RequireResolveDependency(
					param.string,
					param.range,
					getContext()
				);
				dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				dep.optional = !!parser.scope.inTry;
				dep.weak = weak;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
<<<<<<< HEAD
		/**
		 * @param {CallExpression} expr call expression
		 * @param {BasicEvaluatedExpression} param param
		 * @param {boolean} weak weak
		 * @returns {boolean | void} true when handled
		 */
		const processResolveContext = (expr, param, weak) => {
			const dep = ContextDependencyHelpers.create(
				RequireResolveContextDependency,
				/** @type {Range} */ (param.range),
=======
		const processResolveContext = (expr, param, weak) => {
			const dep = ContextDependencyHelpers.create(
				RequireResolveContextDependency,
				param.range,
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				param,
				expr,
				options,
				{
					category: "commonjs",
					mode: weak ? "weak" : "sync"
				},
				parser,
				getContext()
			);
			if (!dep) return;
<<<<<<< HEAD
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
			dep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.call
			.for("require.resolve")
			.tap("CommonJsImportsParserPlugin", expr => {
				return processResolve(expr, false);
			});
		parser.hooks.call
			.for("require.resolveWeak")
			.tap("CommonJsImportsParserPlugin", expr => {
				return processResolve(expr, true);
			});
		//#endregion

		//#region Create require

		if (!options.createRequire) return;

<<<<<<< HEAD
		/** @type {ImportSource[]} */
		let moduleName = [];
		/** @type {string | undefined} */
		let specifierName;

		if (options.createRequire === true) {
			moduleName = ["module", "node:module"];
			specifierName = "createRequire";
		} else {
			let moduleName;
=======
		let moduleName;
		let specifierName;

		if (options.createRequire === true) {
			moduleName = "module";
			specifierName = "createRequire";
		} else {
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			const match = /^(.*) from (.*)$/.exec(options.createRequire);
			if (match) {
				[, specifierName, moduleName] = match;
			}
			if (!specifierName || !moduleName) {
				const err = new WebpackError(
					`Parsing javascript parser option "createRequire" failed, got ${JSON.stringify(
						options.createRequire
					)}`
				);
				err.details =
					'Expected string in format "createRequire from module", where "createRequire" is specifier name and "module" name of the module';
				throw err;
			}
		}

		tapRequireExpressionTag(createdRequireIdentifierTag);
		tapRequireExpressionTag(createRequireSpecifierTag);
		parser.hooks.evaluateCallExpression
			.for(createRequireSpecifierTag)
			.tap("CommonJsImportsParserPlugin", expr => {
				const context = parseCreateRequireArguments(expr);
				if (context === undefined) return;
				const ident = parser.evaluatedVariable({
					tag: createdRequireIdentifierTag,
					data: { context },
					next: undefined
				});
				return new BasicEvaluatedExpression()
<<<<<<< HEAD
					.setIdentifier(
						/** @type {TODO} */ (ident),
						/** @type {TODO} */ (ident),
						() => []
					)
					.setSideEffects(false)
					.setRange(/** @type {Range} */ (expr.range));
=======
					.setIdentifier(ident, ident, () => [])
					.setSideEffects(false)
					.setRange(expr.range);
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			});
		parser.hooks.unhandledExpressionMemberChain
			.for(createdRequireIdentifierTag)
			.tap("CommonJsImportsParserPlugin", (expr, members) => {
				return expressionIsUnsupported(
					parser,
					`createRequire().${members.join(".")} is not supported by webpack.`
				)(expr);
			});
		parser.hooks.canRename
			.for(createdRequireIdentifierTag)
			.tap("CommonJsImportsParserPlugin", () => true);
		parser.hooks.canRename
			.for(createRequireSpecifierTag)
			.tap("CommonJsImportsParserPlugin", () => true);
		parser.hooks.rename
			.for(createRequireSpecifierTag)
			.tap("CommonJsImportsParserPlugin", defineUndefined);
		parser.hooks.expression
			.for(createdRequireIdentifierTag)
			.tap("CommonJsImportsParserPlugin", requireAsExpressionHandler);
		parser.hooks.call
			.for(createdRequireIdentifierTag)
			.tap("CommonJsImportsParserPlugin", createRequireHandler(false));
		/**
<<<<<<< HEAD
		 * @param {CallExpression} expr call expression
		 * @returns {string | void} context
=======
		 * @param {CallExpressionNode} expr call expression
		 * @returns {string} context
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
		 */
		const parseCreateRequireArguments = expr => {
			const args = expr.arguments;
			if (args.length !== 1) {
				const err = new WebpackError(
					"module.createRequire supports only one argument."
				);
<<<<<<< HEAD
				err.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
				err.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.module.addWarning(err);
				return;
			}
			const arg = args[0];
			const evaluated = parser.evaluateExpression(arg);
			if (!evaluated.isString()) {
				const err = new WebpackError(
					"module.createRequire failed parsing argument."
				);
<<<<<<< HEAD
				err.loc = /** @type {DependencyLocation} */ (arg.loc);
				parser.state.module.addWarning(err);
				return;
			}
			const ctx = /** @type {string} */ (evaluated.string).startsWith("file://")
				? fileURLToPath(/** @type {string} */ (evaluated.string))
				: /** @type {string} */ (evaluated.string);
=======
				err.loc = arg.loc;
				parser.state.module.addWarning(err);
				return;
			}
			const ctx = evaluated.string.startsWith("file://")
				? fileURLToPath(evaluated.string)
				: evaluated.string;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
			// argument always should be a filename
			return ctx.slice(0, ctx.lastIndexOf(ctx.startsWith("/") ? "/" : "\\"));
		};

		parser.hooks.import.tap(
			{
				name: "CommonJsImportsParserPlugin",
				stage: -10
			},
			(statement, source) => {
				if (
<<<<<<< HEAD
					!moduleName.includes(source) ||
=======
					source !== moduleName ||
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
					statement.specifiers.length !== 1 ||
					statement.specifiers[0].type !== "ImportSpecifier" ||
					statement.specifiers[0].imported.type !== "Identifier" ||
					statement.specifiers[0].imported.name !== specifierName
				)
					return;
				// clear for 'import { createRequire as x } from "module"'
				// if any other specifier was used import module
				const clearDep = new ConstDependency(
<<<<<<< HEAD
					parser.isAsiPosition(/** @type {Range} */ (statement.range)[0])
						? ";"
						: "",
					/** @type {Range} */ (statement.range)
				);
				clearDep.loc = /** @type {DependencyLocation} */ (statement.loc);
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(/** @type {Range} */ (statement.range)[1]);
=======
					parser.isAsiPosition(statement.range[0]) ? ";" : "",
					statement.range
				);
				clearDep.loc = statement.loc;
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(statement.range[1]);
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			{
				name: "CommonJsImportsParserPlugin",
				stage: -10
			},
			(statement, source, id, name) => {
<<<<<<< HEAD
				if (!moduleName.includes(source) || id !== specifierName) return;
=======
				if (source !== moduleName || id !== specifierName) return;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.tagVariable(name, createRequireSpecifierTag);
				return true;
			}
		);
		parser.hooks.preDeclarator.tap(
			"CommonJsImportsParserPlugin",
			declarator => {
				if (
					declarator.id.type !== "Identifier" ||
					!declarator.init ||
					declarator.init.type !== "CallExpression" ||
					declarator.init.callee.type !== "Identifier"
				)
					return;
<<<<<<< HEAD
				const variableInfo =
					/** @type {TODO} */
					(parser.getVariableInfo(declarator.init.callee.name));
=======
				const variableInfo = parser.getVariableInfo(
					declarator.init.callee.name
				);
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				if (
					variableInfo &&
					variableInfo.tagInfo &&
					variableInfo.tagInfo.tag === createRequireSpecifierTag
				) {
					const context = parseCreateRequireArguments(declarator.init);
					if (context === undefined) return;
					parser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {
						name: declarator.id.name,
						context
					});
					return true;
				}
			}
		);

		parser.hooks.memberChainOfCallMemberChain
			.for(createRequireSpecifierTag)
			.tap(
				"CommonJsImportsParserPlugin",
				(expr, calleeMembers, callExpr, members) => {
					if (
						calleeMembers.length !== 0 ||
						members.length !== 1 ||
						members[0] !== "cache"
					)
						return;
					// createRequire().cache
					const context = parseCreateRequireArguments(callExpr);
					if (context === undefined) return;
					return requireCache(expr);
				}
			);
		parser.hooks.callMemberChainOfCallMemberChain
			.for(createRequireSpecifierTag)
			.tap(
				"CommonJsImportsParserPlugin",
				(expr, calleeMembers, innerCallExpression, members) => {
					if (
						calleeMembers.length !== 0 ||
						members.length !== 1 ||
						members[0] !== "resolve"
					)
						return;
					// createRequire().resolve()
					return processResolve(expr, false);
				}
			);
		parser.hooks.expressionMemberChain
			.for(createdRequireIdentifierTag)
			.tap("CommonJsImportsParserPlugin", (expr, members) => {
				// require.cache
				if (members.length === 1 && members[0] === "cache") {
					return requireCache(expr);
				}
			});
		parser.hooks.callMemberChain
			.for(createdRequireIdentifierTag)
			.tap("CommonJsImportsParserPlugin", (expr, members) => {
				// require.resolve()
				if (members.length === 1 && members[0] === "resolve") {
					return processResolve(expr, false);
				}
			});
		parser.hooks.call
			.for(createRequireSpecifierTag)
			.tap("CommonJsImportsParserPlugin", expr => {
				const clearDep = new ConstDependency(
					"/* createRequire() */ undefined",
<<<<<<< HEAD
					/** @type {Range} */ (expr.range)
				);
				clearDep.loc = /** @type {DependencyLocation} */ (expr.loc);
=======
					expr.range
				);
				clearDep.loc = expr.loc;
>>>>>>> ab4424251e3c4a3188491801dfcd1cc2364c65cb
				parser.state.module.addPresentationalDependency(clearDep);
				return true;
			});
		//#endregion
	}
}
module.exports = CommonJsImportsParserPlugin;
